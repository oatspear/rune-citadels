# Rune Game Development Guide

## Core Concepts

- Rune is a platform for multiplayer mobile games with voice chat
- Games only run on mobile devices with touch controls (no keyboard controls)
- Screen size is fixed once game starts (no resize/orientation change handling needed)
- Default orientation is portrait mode, can be set to landscape via `landscape: true` in `Rune.initLogic()`
- Always use the check-rune-project-errors tool after making changes

## Server-Side Logic Requirements

Rune runs game logic on both clients and server, requiring deterministic code in `logic.js`:

### Prohibited in logic.js:

- External variable mutation/assignment
- Async/await syntax (logic must be synchronous)
- Try/catch blocks (throwing errors is allowed)
- Eval statements
- This keyword
- Non-deterministic functions (Date, fetch, etc.)
- Regular expressions

## Game State Architecture

### Game Logic (`logic.js`)

```js
Rune.initLogic({
  minPlayers: 1 - 6, // <= maxPlayers
  maxPlayers: 1 - 6, // >= minPlayers
  setup: () => {
    return {
      // Initial game state
    }
  },
  actions: {
    actionName: (payload, { game, playerId }) => {
      // Update game state
    },
  },
})
```

### Client Rendering (`client.js`)

```js
const onChange = ({
  previousGame,
  game,
  action,
  event,
  players,
  yourPlayerId,
}) => {
  // Update UI based on game state
}

Rune.initClient({ onChange })
```

## Game State Synchronization

- Client performs action that updates local game state
- Action sent to server for validation
- Valid actions propagate to all clients
- Each client computes new state using action payload

### Restrictions:

- Max 10 actions per player per second
- Actions must execute in <10ms and use <1MB memory
- Game state must be <1MB, action payload <25KB
- Game state must be JSON-serializable
- `logic.js` must be <1MB

## Player Management

- `yourPlayerId` in `onChange` identifies the client (undefined for spectators)
- Use `Rune.getPlayerInfo(playerId)` to get player data (name, avatar)

## Time Synchronization

- `Rune.gameTime()`: milliseconds since game start
- `Rune.worldTime()`: universal timestamp (milliseconds since Jan 1, 1970)

## Real-Time Update Loop

```js
Rune.initLogic({
  update: ({ game }) => {
    // Logic run on interval
  },
  updatesPerSecond: 1 - 30, // Default: 1
})
```

## Reducing Visual Stutter

- Use `Rune.interpolator()` for smooth rendering between updates
- Use `Rune.interpolatorLatency()` for smoother opponent movements

### Basic Interpolation:

```js
const interpolator = Rune.interpolator()

function onChange({ game, futureGame }) {
  interpolator.update({
    game: game.position,
    futureGame: futureGame.position,
  })
}

function render() {
  const position = interpolator.getPosition()
  // Draw at interpolated position
}
```

## Events

- Generated by Rune, not by game code
- Events: `playerJoined`, `playerLeft`, `stateSync`, `update`, `timeSync`
- Handle player joining/leaving with optional callbacks:

```js
Rune.initLogic({
  // ...other configs
  events: {
    playerJoined: (playerId, { game }) => {
      // Initialize player in game
    },
    playerLeft: (playerId, { game }) => {
      // Handle player departure
    },
  },
})
```

## Randomness

- `Math.random()` is made deterministic by Rune
- Keep all shared state in `logic.js`
- Generate random state in `setup()` for all players to see same values

## Player Join/Leave Handling

- `minPlayers`: game can't start with fewer (1-4)
- `maxPlayers`: excess players become spectators
- Game ends if active players drop below `minPlayers`
- Implement `playerJoined`/`playerLeft` to support mid-game joining/leaving

# Game Over

Call `Rune.gameOver(options)` when your game ends to trigger Rune's game over popup with the following options:

### Game Results Options

1. **Cooperative Games**: Use `everyone` property for common results

   ```js
   Rune.gameOver({ everyone: 300 })
   ```

2. **Competitive Games**: Use `players` object with "WON", "LOST", or "TIE" values

   ```js
   Rune.gameOver({
     players: {
       [playerIdA]: "WON",
       [playerIdB]: "LOST",
       [playerIdC]: "TIE",
     },
   })
   ```

3. **Score-Based Games**: Assign numeric scores to players (highest wins)
   ```js
   Rune.gameOver({
     players: {
       [playerIdA]: 21981,
       [playerIdB]: 8911,
     },
   })
   ```

### Additional Options

- `minimizePopUp: true`: Initially show popup in minimized state
- `delayPopUp: true`: Postpone popup display until `Rune.showGameOverPopUp()` is called (auto-shows after a few seconds if not called)
